<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Graph Visualizer with Operations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #666;
            font-size: 14px;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-group label {
            font-weight: bold;
            color: #555;
        }
        input[type="text"], input[type="number"], select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            padding: 8px 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #45a049;
        }
        button.danger {
            background: #f44336;
        }
        button.danger:hover {
            background: #d32f2f;
        }
        button.secondary {
            background: #2196F3;
        }
        button.secondary:hover {
            background: #1976D2;
        }
        button.warning {
            background: #ff9800;
        }
        button.warning:hover {
            background: #f57c00;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .operations-panel {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border: 2px solid #4CAF50;
        }
        .operations-panel h3 {
            margin-top: 0;
            color: #2e7d32;
        }
        #graph {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }
        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
            transition: all 0.3s;
        }
        .node:hover {
            stroke-width: 3px;
        }
        .node.selected {
            stroke: #ff6b6b;
            stroke-width: 4px;
        }
        .node.highlighted {
            fill: #ff6b6b !important;
            stroke: #d32f2f !important;
            stroke-width: 4px !important;
        }
        .node.path-node {
            fill: #ffa726 !important;
            stroke: #f57c00 !important;
            stroke-width: 3px !important;
        }
        .node.start-node {
            fill: #66bb6a !important;
            stroke: #388e3c !important;
            stroke-width: 4px !important;
        }
        .node.end-node {
            fill: #ef5350 !important;
            stroke: #c62828 !important;
            stroke-width: 4px !important;
        }
        .node.path-intermediate {
            fill: #ffa726 !important;
            stroke: #f57c00 !important;
            stroke-width: 3px !important;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.8;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
            cursor: pointer;
            transition: all 0.3s;
        }
        .link:hover {
            stroke: #333;
            stroke-width: 3px;
        }
        .link.highlighted {
            stroke: #ff6b6b !important;
            stroke-width: 4px !important;
            stroke-opacity: 1 !important;
        }
        .link.path-link {
            stroke: #ffa726 !important;
            stroke-width: 3px !important;
            stroke-opacity: 1 !important;
        }
        .node-label {
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
        }
        .sidebar {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .panel {
            flex: 1;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        .panel h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 8px;
        }
        .results-panel {
            background: #fff3e0;
            border: 2px solid #ff9800;
        }
        .results-panel h3 {
            border-bottom-color: #ff9800;
            color: #e65100;
        }
        .result-item {
            background: white;
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            border-left: 4px solid #ff9800;
            font-family: 'Courier New', monospace;
        }
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-weight: bold;
        }
        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .legend {
            background: #e3f2fd;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 12px;
        }
        .legend-item {
            display: inline-block;
            margin: 2px 8px;
        }
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 4px;
            vertical-align: middle;
        }
        .matrix-display {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            max-height: 200px;
            overflow: auto;
            white-space: pre;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Enhanced Graph Visualizer</h1>
            <p class="subtitle">Create graphs and run operations with visual feedback</p>
        </div>

        <!-- Main Controls -->
        <div class="controls">
            <div class="control-group">
                <label for="nodeInput">Add Node:</label>
                <input type="text" id="nodeInput" placeholder="Node name">
                <button onclick="addNode()">Add Node</button>
            </div>
            <div class="control-group">
                <button onclick="addEdge()" id="addEdgeBtn" disabled>Add Edge</button>
                <span id="selectionInfo" style="color: #666; font-size: 12px;"></span>
            </div>
            <div class="control-group">
                <button class="danger" onclick="clearGraph()">Clear Graph</button>
                <button class="secondary" onclick="loadSample()">Load Sample</button>
                <button onclick="loadJSON()">Load JSON</button>
            </div>
        </div>

        <!-- Graph Operations Panel -->
        <div class="operations-panel">
            <h3>üîç Graph Operations</h3>
            <div class="controls">
                <div class="control-group">
                    <label for="startNode">Start Node:</label>
                    <select id="startNode">
                        <option value="">Select node...</option>
                    </select>
                </div>
                <div class="control-group">
                    <button class="warning" onclick="runDFS()" id="dfsBtn" disabled>Run DFS</button>
                    <button class="warning" onclick="runBFS()" id="bfsBtn" disabled>Run BFS</button>
                    <button class="secondary" onclick="showNeighbors()" id="neighborsBtn" disabled>Show Neighbors</button>
                </div>
                <div class="control-group">
                    <label for="fromNode">From:</label>
                    <select id="fromNode">
                        <option value="">Select from node...</option>
                    </select>
                    <label for="toNode">To:</label>
                    <select id="toNode">
                        <option value="">Select to node...</option>
                    </select>
                    <button class="secondary" onclick="findPath()" id="pathBtn" disabled>Find Path</button>
                </div>
                <div class="control-group">
                    <button onclick="clearHighlights()">Clear Highlights</button>
                    <label for="exportFilename">Export as:</label>
                    <input type="text" id="exportFilename" placeholder="graph_matrix" value="graph_matrix">
                    <button onclick="exportGraph()">Export CSV Matrix</button>
                    <button onclick="exportJSON()">Export JSON</button>
                </div>
            </div>
        </div>

        <!-- Graph Visualization -->
        <div id="graph"></div>

        <!-- Results and Info Panels -->
        <div class="sidebar">
            <div class="panel">
                <h3>üìä Graph Info</h3>
                <div id="graphStats">
                    <p>Nodes: <span id="nodeCount">0</span></p>
                    <p>Edges: <span id="edgeCount">0</span></p>
                    <p>Density: <span id="density">0.000</span></p>
                </div>
                <div class="legend">
                    <h4>Legend:</h4>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #4CAF50;"></span>Normal
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #66bb6a;"></span>Start Node
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ef5350;"></span>End Node
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ffa726;"></span>Path Node
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ff6b6b;"></span>Highlighted
                    </div>
                </div>
                <div id="matrixDisplay" class="matrix-display" style="display: none;"></div>
            </div>
            <div class="panel results-panel">
                <h3>üìã Operation Results</h3>
                <div id="operationResults">
                    <p style="color: #666; font-style: italic;">Run an operation to see results...</p>
                </div>
            </div>
        </div>

        <div id="statusMessage"></div>
        
        <!-- Hidden file input for JSON loading -->
        <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="handleJSONFile(event)">
    </div>

    <script>
        // Graph data
        let graphData = { nodes: [], links: [] };
        let selectedNodes = [];
        let nodeIdCounter = 0;

        // D3 setup
        const width = 1560;
        const height = 600;

        const svg = d3.select("#graph")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Define arrow marker
        svg.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 25)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#666");

        // Force simulation
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(25))
            .force("x", d3.forceX(width / 2).strength(0.1))
            .force("y", d3.forceY(height / 2).strength(0.1));

        // Graph elements
        let link = svg.append("g").selectAll("line");
        let node = svg.append("g").selectAll("circle");
        let label = svg.append("g").selectAll("text");

        // Initialize with empty graph
        updateVisualization();
        updateStats();
        updateStartNodeOptions();
        showStatus("Welcome! Start by adding nodes to create your graph.", "success");

        function addNode() {
            const input = document.getElementById('nodeInput');
            const nodeName = input.value.trim();
            
            if (!nodeName) {
                showStatus("Please enter a node name.", "warning");
                return;
            }
            
            if (graphData.nodes.find(n => n.id === nodeName)) {
                showStatus("Node already exists!", "error");
                return;
            }
            
            graphData.nodes.push({
                id: nodeName,
                name: nodeName,
                x: Math.random() * (width - 100) + 50,
                y: Math.random() * (height - 100) + 50
            });
            
            input.value = '';
            updateVisualization();
            updateStats();
            updateStartNodeOptions();
            showStatus(`Added node: ${nodeName}`, "success");
        }

        function addEdge() {
            if (selectedNodes.length !== 2) {
                showStatus("Select exactly 2 nodes to add an edge.", "warning");
                return;
            }
            
            const [source, target] = selectedNodes;
            
            // Check if edge already exists
            if (graphData.links.find(l => l.source.id === source && l.target.id === target)) {
                showStatus("Edge already exists!", "error");
                return;
            }
            
            graphData.links.push({
                source: source,
                target: target,
                weight: 1
            });
            
            selectedNodes = [];
            updateVisualization();
            updateStats();
            updateSelectionUI();
            showStatus(`Added edge: ${source} ‚Üí ${target}`, "success");
        }

        function clearGraph() {
            if (graphData.nodes.length > 0 && !confirm('Clear all nodes and edges?')) {
                return;
            }
            
            graphData = { nodes: [], links: [] };
            selectedNodes = [];
            updateVisualization();
            updateStats();
            updateStartNodeOptions();
            clearOperationResults();
            hideMatrix();
            showStatus("Graph cleared.", "success");
        }

        function loadSample() {
            graphData = {
                nodes: [
                    { id: "A", name: "A", x: width * 0.2, y: height * 0.3 },
                    { id: "B", name: "B", x: width * 0.4, y: height * 0.2 },
                    { id: "C", name: "C", x: width * 0.6, y: height * 0.3 },
                    { id: "D", name: "D", x: width * 0.4, y: height * 0.6 },
                    { id: "E", name: "E", x: width * 0.5, y: height * 0.8 }
                ],
                links: [
                    { source: "A", target: "B", weight: 1 },
                    { source: "B", target: "C", weight: 1 },
                    { source: "B", target: "D", weight: 1 },
                    { source: "C", target: "E", weight: 1 },
                    { source: "D", target: "E", weight: 1 }
                ]
            };
            
            selectedNodes = [];
            updateVisualization();
            updateStats();
            updateStartNodeOptions();
            showStatus("Sample graph loaded!", "success");
        }

        function loadJSON() {
            document.getElementById('jsonFileInput').click();
        }

        function handleJSONFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Handle different JSON formats
                    if (data.nodes && data.links) {
                        // D3 format
                        graphData = data;
                    } else if (data.nodes && data.edges) {
                        // CLI format - convert edges to links
                        graphData = {
                            nodes: data.nodes.map(n => ({ 
                                id: n.id, 
                                name: n.label || n.id,
                                x: n.x || Math.random() * (width - 100) + 50,
                                y: n.y || Math.random() * (height - 100) + 50
                            })),
                            links: data.edges.map(e => ({ 
                                source: e.from, 
                                target: e.to, 
                                weight: e.weight || 1 
                            }))
                        };
                    } else {
                        throw new Error("Unsupported JSON format");
                    }
                    
                    selectedNodes = [];
                    updateVisualization();
                    updateStats();
                    updateStartNodeOptions();
                    showStatus(`JSON loaded: ${graphData.nodes.length} nodes, ${graphData.links.length} edges`, "success");
                } catch (error) {
                    showStatus(`Error loading JSON: ${error.message}`, "error");
                }
            };
            reader.readAsText(file);
        }

        function runDFS() {
            const startNodeId = document.getElementById('startNode').value;
            if (!startNodeId) {
                showStatus("Please select a start node.", "warning");
                return;
            }

            clearHighlights();
            const visited = new Set();
            const path = [];
            
            function dfsRecursive(nodeId) {
                if (visited.has(nodeId)) return;
                
                visited.add(nodeId);
                path.push(nodeId);
                
                // Find neighbors (outgoing edges)
                const neighbors = graphData.links
                    .filter(l => (l.source.id || l.source) === nodeId)
                    .map(l => l.target.id || l.target);
                
                neighbors.forEach(neighbor => {
                    if (!visited.has(neighbor)) {
                        dfsRecursive(neighbor);
                    }
                });
            }
            
            dfsRecursive(startNodeId);
            highlightPath(path, startNodeId);
            showOperationResults("DFS Traversal", path, startNodeId);
        }

        function runBFS() {
            const startNodeId = document.getElementById('startNode').value;
            if (!startNodeId) {
                showStatus("Please select a start node.", "warning");
                return;
            }

            clearHighlights();
            const visited = new Set();
            const queue = [startNodeId];
            const path = [];
            
            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;
                
                visited.add(current);
                path.push(current);
                
                // Find neighbors (outgoing edges)
                const neighbors = graphData.links
                    .filter(l => (l.source.id || l.source) === current)
                    .map(l => l.target.id || l.target);
                
                neighbors.forEach(neighbor => {
                    if (!visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                });
            }
            
            highlightPath(path, startNodeId);
            showOperationResults("BFS Traversal", path, startNodeId);
        }

        function showNeighbors() {
            const startNodeId = document.getElementById('startNode').value;
            if (!startNodeId) {
                showStatus("Please select a node to show neighbors.", "warning");
                return;
            }

            clearHighlights();
            
            // Find all neighbors (outgoing edges)
            const neighbors = graphData.links
                .filter(l => (l.source.id || l.source) === startNodeId)
                .map(l => l.target.id || l.target);
            
            // Highlight start node and neighbors
            highlightNodes([startNodeId, ...neighbors], startNodeId);
            highlightConnectedEdges(startNodeId);
            
            showOperationResults("Neighbors", neighbors, startNodeId);
        }

        function findPath() {
            const fromNodeId = document.getElementById('fromNode').value;
            const toNodeId = document.getElementById('toNode').value;
            
            if (!fromNodeId || !toNodeId) {
                showStatus("Please select both from and to nodes.", "warning");
                return;
            }
            
            if (fromNodeId === toNodeId) {
                showStatus("From and to nodes cannot be the same.", "warning");
                return;
            }
            
            clearHighlights();
            
            // Find shortest path using BFS
            const path = findShortestPath(fromNodeId, toNodeId);
            
            if (path.length === 0) {
                showStatus(`No path found between ${fromNodeId} and ${toNodeId}.`, "error");
                showOperationResults("Path Finding", [], fromNodeId);
                return;
            }
            
            // Highlight the path
            highlightPathBetweenNodes(path, fromNodeId, toNodeId);
            showOperationResults("Shortest Path", path, fromNodeId, toNodeId);
            showStatus(`Path found: ${path.join(' ‚Üí ')}`, "success");
        }
        
        function findShortestPath(start, end) {
            const visited = new Set();
            const queue = [{node: start, path: [start]}];
            
            while (queue.length > 0) {
                const {node, path} = queue.shift();
                
                if (node === end) {
                    return path;
                }
                
                if (visited.has(node)) {
                    continue;
                }
                
                visited.add(node);
                
                // Find all neighbors (both outgoing and incoming edges for undirected behavior)
                const neighbors = new Set();
                
                // Outgoing edges
                graphData.links.forEach(l => {
                    if ((l.source.id || l.source) === node) {
                        neighbors.add(l.target.id || l.target);
                    }
                    // Incoming edges (treat as undirected)
                    if ((l.target.id || l.target) === node) {
                        neighbors.add(l.source.id || l.source);
                    }
                });
                
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push({
                            node: neighbor,
                            path: [...path, neighbor]
                        });
                    }
                }
            }
            
            return []; // No path found
        }
        
        function highlightPathBetweenNodes(path, fromNode, toNode) {
            // Clear all previous highlights
            node.classed("highlighted", false)
                .classed("start-node", false)
                .classed("end-node", false)
                .classed("path-node", false)
                .classed("path-intermediate", false);
                
            link.classed("highlighted", false)
                .classed("path-link", false);
            
            // Highlight nodes in the path
            node.classed("start-node", d => d.id === fromNode)
                .classed("end-node", d => d.id === toNode)
                .classed("path-intermediate", d => path.includes(d.id) && d.id !== fromNode && d.id !== toNode);
            
            // Highlight edges in the path
            for (let i = 0; i < path.length - 1; i++) {
                const sourceId = path[i];
                const targetId = path[i + 1];
                
                link.classed("path-link", l => {
                    const linkSource = l.source.id || l.source;
                    const linkTarget = l.target.id || l.target;
                    
                    return (linkSource === sourceId && linkTarget === targetId) ||
                           (linkSource === targetId && linkTarget === sourceId); // Handle undirected
                });
            }
        }

        function highlightPath(path, startNodeId) {
            // Clear all previous highlights
            node.classed("highlighted", false)
                .classed("start-node", false)
                .classed("path-node", false);
                
            link.classed("highlighted", false)
                .classed("path-link", false);
            
            // Apply new highlights
            node.classed("start-node", d => d.id === startNodeId)
                .classed("path-node", d => path.includes(d.id) && d.id !== startNodeId);
            
            // Highlight edges in path order
            for (let i = 0; i < path.length - 1; i++) {
                const sourceId = path[i];
                const targetId = path[i + 1];
                
                link.classed("highlighted", l => 
                    (l.source.id || l.source) === sourceId && 
                    (l.target.id || l.target) === targetId
                );
            }
        }

        function highlightNodes(nodeIds, startNodeId) {
            // Clear previous highlights
            node.classed("highlighted", false)
                .classed("start-node", false)
                .classed("path-node", false);
                
            // Apply new highlights
            node.classed("start-node", d => d.id === startNodeId)
                .classed("highlighted", d => nodeIds.includes(d.id) && d.id !== startNodeId);
        }

        function highlightConnectedEdges(nodeId) {
            link.classed("highlighted", l => (l.source.id || l.source) === nodeId);
        }

        function clearHighlights() {
            node.classed("highlighted", false)
                .classed("start-node", false)
                .classed("end-node", false)
                .classed("path-node", false)
                .classed("path-intermediate", false)
                .classed("selected", false);
            link.classed("highlighted", false)
                .classed("path-link", false);
        }

        function showOperationResults(operation, results, startNode, endNode = null) {
            const resultsDiv = document.getElementById('operationResults');
            
            if (operation === "Shortest Path") {
                resultsDiv.innerHTML = `
                    <h4>${operation} Results</h4>
                    <p><strong>From:</strong> ${startNode}</p>
                    <p><strong>To:</strong> ${endNode}</p>
                    <p><strong>Path:</strong> ${results.join(' ‚Üí ')}</p>
                    <p><strong>Path Length:</strong> ${results.length} nodes (${results.length - 1} edges)</p>
                    <div style="margin-top: 10px;">
                        ${results.map((node, i) => `
                            <div class="result-item">
                                Step ${i + 1}: ${node}${i === 0 ? ' (start)' : i === results.length - 1 ? ' (end)' : ''}
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                resultsDiv.innerHTML = `
                    <h4>${operation} Results</h4>
                    <p><strong>Start Node:</strong> ${startNode}</p>
                    <p><strong>Result:</strong> ${results.join(' ‚Üí ')}</p>
                    <p><strong>Nodes Visited:</strong> ${results.length}</p>
                    <div style="margin-top: 10px;">
                        ${results.map((node, i) => `
                            <div class="result-item">
                                Step ${i + 1}: ${node}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }

        function clearOperationResults() {
            document.getElementById('operationResults').innerHTML = 
                '<p style="color: #666; font-style: italic;">Run an operation to see results...</p>';
        }

        function exportGraph() {
            if (graphData.nodes.length === 0) {
                showStatus("No graph to export!", "warning");
                return;
            }
            
            // Create adjacency matrix
            const nodes = graphData.nodes.map(n => n.id);
            const matrix = nodes.map(() => nodes.map(() => 0));
            
            graphData.links.forEach(link => {
                const sourceId = link.source.id || link.source;
                const targetId = link.target.id || link.target;
                const sourceIndex = nodes.indexOf(sourceId);
                const targetIndex = nodes.indexOf(targetId);
                if (sourceIndex >= 0 && targetIndex >= 0) {
                    matrix[sourceIndex][targetIndex] = link.weight || 1;
                }
            });
            
            // Get custom filename
            const filenameInput = document.getElementById('exportFilename');
            let filename = filenameInput.value.trim() || 'graph_matrix';
            
            // Ensure .csv extension
            if (!filename.endsWith('.csv')) {
                filename += '.csv';
            }
            
            // Create CSV content
            const csvContent = matrix.map(row => row.join(',')).join('\\n');
            
            // Download file
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            // Show matrix in panel
            showMatrix(matrix, nodes);
            showStatus(`Graph exported as ${filename}!`, "success");
        }

        function exportJSON() {
            if (graphData.nodes.length === 0) {
                showStatus("No graph to export!", "warning");
                return;
            }
            
            // Export in CLI-compatible format
            const exportData = {
                nodes: graphData.nodes.map(n => ({
                    id: n.id,
                    label: n.name || n.id,
                    x: n.x || 0,
                    y: n.y || 0
                })),
                edges: graphData.links.map(l => ({
                    from: l.source.id || l.source,
                    to: l.target.id || l.target,
                    weight: l.weight || 1,
                    label: ""
                })),
                properties: {
                    vertices: graphData.nodes.length,
                    edges: graphData.links.length,
                    density: calculateDensity()
                }
            };
            
            // Get custom filename
            const filenameInput = document.getElementById('exportFilename');
            let filename = filenameInput.value.trim() || 'graph_export';
            
            // Ensure .json extension
            if (!filename.endsWith('.json')) {
                filename += '.json';
            }
            
            const jsonContent = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            
            showStatus(`Graph exported as ${filename}!`, "success");
        }

        function showMatrix(matrix, nodeLabels) {
            const matrixDiv = document.getElementById('matrixDisplay');
            let matrixText = '     ' + nodeLabels.join('  ') + '\\n';
            matrix.forEach((row, i) => {
                matrixText += nodeLabels[i].padEnd(3) + ' ' + row.join('  ') + '\\n';
            });
            matrixDiv.textContent = matrixText;
            matrixDiv.style.display = 'block';
        }

        function hideMatrix() {
            document.getElementById('matrixDisplay').style.display = 'none';
        }

        function calculateDensity() {
            const nodeCount = graphData.nodes.length;
            const edgeCount = graphData.links.length;
            const maxEdges = nodeCount * (nodeCount - 1);
            return maxEdges > 0 ? (edgeCount / maxEdges) : 0;
        }

        function updateVisualization() {
            // Update links
            link = link.data(graphData.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
            link.exit().remove();
            link = link.enter().append("line")
                .attr("class", "link")
                .merge(link);

            // Update nodes
            node = node.data(graphData.nodes, d => d.id);
            node.exit().remove();
            const nodeEnter = node.enter().append("circle")
                .attr("class", "node")
                .attr("r", 12)
                .attr("fill", "#4CAF50")
                .on("click", handleNodeClick)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            node = nodeEnter.merge(node);

            // Update labels
            label = label.data(graphData.nodes, d => d.id);
            label.exit().remove();
            label = label.enter().append("text")
                .attr("class", "node-label")
                .merge(label)
                .text(d => d.name);

            // Update simulation
            simulation.nodes(graphData.nodes);
            simulation.force("link").links(graphData.links);
            simulation.alpha(0.3).restart();

            simulation.on("tick", () => {
                // Constrain nodes to canvas bounds
                graphData.nodes.forEach(d => {
                    d.x = Math.max(25, Math.min(width - 25, d.x));
                    d.y = Math.max(25, Math.min(height - 25, d.y));
                });

                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
        }

        function handleNodeClick(event, d) {
            event.stopPropagation();
            
            if (selectedNodes.includes(d.id)) {
                selectedNodes = selectedNodes.filter(id => id !== d.id);
            } else if (selectedNodes.length < 2) {
                selectedNodes.push(d.id);
            } else {
                selectedNodes = [d.id];
            }
            
            // Update node selection visual
            node.classed("selected", n => selectedNodes.includes(n.id));
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const addEdgeBtn = document.getElementById('addEdgeBtn');
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (selectedNodes.length === 0) {
                addEdgeBtn.disabled = true;
                selectionInfo.textContent = "Select 2 nodes to add edge";
            } else if (selectedNodes.length === 1) {
                addEdgeBtn.disabled = true;
                selectionInfo.textContent = `Selected: ${selectedNodes[0]} (select 1 more)`;
            } else if (selectedNodes.length === 2) {
                addEdgeBtn.disabled = false;
                selectionInfo.textContent = `Selected: ${selectedNodes.join(' ‚Üí ')}`;
            }
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = graphData.nodes.length;
            document.getElementById('edgeCount').textContent = graphData.links.length;
            document.getElementById('density').textContent = calculateDensity().toFixed(3);
        }

        function updateStartNodeOptions() {
            const startSelect = document.getElementById('startNode');
            const fromSelect = document.getElementById('fromNode');
            const toSelect = document.getElementById('toNode');
            
            // Clear existing options
            startSelect.innerHTML = '<option value="">Select node...</option>';
            fromSelect.innerHTML = '<option value="">Select from node...</option>';
            toSelect.innerHTML = '<option value="">Select to node...</option>';
            
            // Populate all dropdowns
            graphData.nodes.forEach(node => {
                // Start node dropdown
                const startOption = document.createElement('option');
                startOption.value = node.id;
                startOption.textContent = node.name;
                startSelect.appendChild(startOption);
                
                // From node dropdown
                const fromOption = document.createElement('option');
                fromOption.value = node.id;
                fromOption.textContent = node.name;
                fromSelect.appendChild(fromOption);
                
                // To node dropdown
                const toOption = document.createElement('option');
                toOption.value = node.id;
                toOption.textContent = node.name;
                toSelect.appendChild(toOption);
            });
            
            // Enable/disable operation buttons
            const hasNodes = graphData.nodes.length > 0;
            document.getElementById('dfsBtn').disabled = !hasNodes;
            document.getElementById('bfsBtn').disabled = !hasNodes;
            document.getElementById('neighborsBtn').disabled = !hasNodes;
            document.getElementById('pathBtn').disabled = !hasNodes;
        }

        function findPath() {
            const fromNodeId = document.getElementById('fromNode').value;
            const toNodeId = document.getElementById('toNode').value;
            
            if (!fromNodeId || !toNodeId) {
                showStatus("Please select both from and to nodes.", "warning");
                return;
            }
            
            if (fromNodeId === toNodeId) {
                showStatus("From and to nodes cannot be the same.", "warning");
                return;
            }
            
            clearHighlights();
            const path = findShortestPath(fromNodeId, toNodeId);
            
            if (path.length === 0) {
                showStatus(`No path found from ${fromNodeId} to ${toNodeId}`, "error");
                return;
            }
            
            highlightPathBetweenNodes(path, fromNodeId, toNodeId);
            showOperationResults("Shortest Path", path, fromNodeId, toNodeId);
        }

        function findShortestPath(start, end) {
            const visited = new Set();
            const queue = [{node: start, path: [start]}];
            
            while (queue.length > 0) {
                const {node, path} = queue.shift();
                
                if (node === end) {
                    return path;
                }
                
                if (visited.has(node)) {
                    continue;
                }
                
                visited.add(node);
                
                // Find all neighbors (both outgoing and incoming edges for undirected behavior)
                const neighbors = new Set();
                
                // Outgoing edges
                graphData.links.forEach(l => {
                    if ((l.source.id || l.source) === node) {
                        neighbors.add(l.target.id || l.target);
                    }
                    // Incoming edges (treat as undirected)
                    if ((l.target.id || l.target) === node) {
                        neighbors.add(l.source.id || l.source);
                    }
                });
                
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push({
                            node: neighbor,
                            path: [...path, neighbor]
                        });
                    }
                }
            }
            
            return []; // No path found
        }

        function highlightPathBetweenNodes(path, startNodeId, endNodeId) {
            // Clear all previous highlights
            node.classed("highlighted", false)
                .classed("start-node", false)
                .classed("end-node", false)
                .classed("path-intermediate", false);
                
            link.classed("highlighted", false)
                .classed("path-link", false);
            
            // Apply new highlights
            node.classed("start-node", d => d.id === startNodeId)
                .classed("end-node", d => d.id === endNodeId)
                .classed("path-intermediate", d => 
                    path.includes(d.id) && d.id !== startNodeId && d.id !== endNodeId);
            
            // Highlight edges in path order
            for (let i = 0; i < path.length - 1; i++) {
                const sourceId = path[i];
                const targetId = path[i + 1];
                
                link.classed("path-link", l => {
                    const linkSource = l.source.id || l.source;
                    const linkTarget = l.target.id || l.target;
                    // Check both directions for undirected graph
                    return (linkSource === sourceId && linkTarget === targetId) ||
                           (linkSource === targetId && linkTarget === sourceId);
                });
            }
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message status-${type}">${message}</div>`;
            
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = Math.max(25, Math.min(width - 25, event.x));
            d.fy = Math.max(25, Math.min(height - 25, event.y));
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Handle Enter key in node input
        document.getElementById('nodeInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addNode();
            }
        });

        // Clear selection when clicking on empty space
        svg.on("click", function() {
            selectedNodes = [];
            node.classed("selected", false);
            updateSelectionUI();
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Editor</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .main-content {
            display: flex;
            gap: 20px;
            padding: 20px;
        }
        
        .graph-section {
            flex: 1;
        }
        
        .graph-svg {
            width: 100%;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
            cursor: crosshair;
        }
        
        .sidebar {
            width: 350px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .panel-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .control-row input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #5a6fd8;
        }
        
        button.danger {
            background: #e74c3c;
        }
        
        button.danger:hover {
            background: #c0392b;
        }
        
        button.success {
            background: #27ae60;
        }
        
        button.success:hover {
            background: #219a52;
        }
        
        .matrix-display {
            max-height: 200px;
            overflow: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: white;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .node:hover {
            transform: scale(1.1);
        }
        
        .node-circle {
            fill: #4CAF50;
            stroke: #45a049;
            stroke-width: 2;
        }
        
        .node-selected {
            fill: #ff6b6b !important;
            stroke: #e55656 !important;
        }
        
        .node-text {
            font-size: 14px;
            font-weight: bold;
            fill: white;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .edge {
            stroke: #666;
            stroke-width: 2;
            marker-end: url(#arrowhead);
            cursor: pointer;
        }
        
        .edge:hover {
            stroke: #333;
            stroke-width: 3;
        }
        
        .edge-weighted {
            stroke: #e74c3c;
            stroke-width: 3;
        }
        
        .edge-label {
            font-size: 12px;
            fill: #e74c3c;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .vertex-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        
        .vertex-tag {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .vertex-tag:hover {
            background: #5a6fd8;
        }
        
        .vertex-tag.selected {
            background: #ff6b6b;
        }
        
        .remove-btn {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }
        
        .info-item {
            margin: 5px 0;
            padding: 8px;
            background: white;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .download-section {
            border-top: 1px solid #ddd;
            padding-top: 15px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const GraphEditor = () => {
            const [graphData, setGraphData] = useState({
                nodes: [],
                edges: [],
                properties: { vertices: 0, edges: 0, density: 0 }
            });
            
            const [selectedNodes, setSelectedNodes] = useState([]);
            const [newVertexName, setNewVertexName] = useState('');
            const [edgeWeight, setEdgeWeight] = useState(1);
            const [mode, setMode] = useState('select'); // 'select', 'addVertex', 'addEdge'
            const [loadedFileName, setLoadedFileName] = useState('');
            
            const fileInputRef = useRef(null);
            const svgRef = useRef(null);

            const sampleGraph = {
                nodes: [
                    { id: "A", label: "A", x: 200, y: 100 },
                    { id: "B", label: "B", x: 100, y: 200 },
                    { id: "C", label: "C", x: 300, y: 200 },
                    { id: "D", label: "D", x: 200, y: 300 }
                ],
                edges: [
                    { from: "A", to: "B", weight: 1, label: "" },
                    { from: "B", to: "C", weight: 2, label: "2" },
                    { from: "C", to: "D", weight: 1, label: "" },
                    { from: "D", to: "A", weight: 1, label: "" }
                ],
                properties: { vertices: 4, edges: 4, density: 0.333 }
            };

            useEffect(() => {
                setGraphData(sampleGraph);
                updateGraphProperties(sampleGraph);
            }, []);

            const updateGraphProperties = (data) => {
                const vertices = data.nodes.length;
                const edges = data.edges.length;
                const maxEdges = vertices * (vertices - 1);
                const density = maxEdges > 0 ? (edges / maxEdges) : 0;
                
                const updatedData = {
                    ...data,
                    properties: { vertices, edges, density: density.toFixed(3) }
                };
                setGraphData(updatedData);
            };

            const addVertex = (x = null, y = null) => {
                if (!newVertexName.trim()) return;
                
                const newNode = {
                    id: newVertexName,
                    label: newVertexName,
                    x: x || Math.random() * 400 + 100,
                    y: y || Math.random() * 300 + 100
                };
                
                const newData = {
                    ...graphData,
                    nodes: [...graphData.nodes, newNode]
                };
                
                updateGraphProperties(newData);
                setNewVertexName('');
            };

            const removeVertex = (vertexId) => {
                const newData = {
                    nodes: graphData.nodes.filter(node => node.id !== vertexId),
                    edges: graphData.edges.filter(edge => edge.from !== vertexId && edge.to !== vertexId)
                };
                
                updateGraphProperties(newData);
                setSelectedNodes(selectedNodes.filter(id => id !== vertexId));
            };

            const addEdge = () => {
                if (selectedNodes.length !== 2) return;
                
                const [from, to] = selectedNodes;
                const existingEdge = graphData.edges.find(e => e.from === from && e.to === to);
                
                if (existingEdge) {
                    // Update existing edge weight
                    const newData = {
                        ...graphData,
                        edges: graphData.edges.map(edge => 
                            edge.from === from && edge.to === to 
                                ? { ...edge, weight: parseInt(edgeWeight), label: edgeWeight == 1 ? "" : edgeWeight.toString() }
                                : edge
                        )
                    };
                    updateGraphProperties(newData);
                } else {
                    // Add new edge
                    const newEdge = {
                        from,
                        to,
                        weight: parseInt(edgeWeight),
                        label: edgeWeight == 1 ? "" : edgeWeight.toString()
                    };
                    
                    const newData = {
                        ...graphData,
                        edges: [...graphData.edges, newEdge]
                    };
                    updateGraphProperties(newData);
                }
                
                setSelectedNodes([]);
            };

            const removeEdge = (from, to) => {
                const newData = {
                    ...graphData,
                    edges: graphData.edges.filter(edge => !(edge.from === from && edge.to === to))
                };
                updateGraphProperties(newData);
            };

            const handleNodeClick = (nodeId) => {
                if (mode === 'select') {
                    if (selectedNodes.includes(nodeId)) {
                        setSelectedNodes(selectedNodes.filter(id => id !== nodeId));
                    } else if (selectedNodes.length < 2) {
                        setSelectedNodes([...selectedNodes, nodeId]);
                    } else {
                        setSelectedNodes([nodeId]);
                    }
                }
            };

            const handleSvgClick = (event) => {
                if (mode === 'addVertex' && newVertexName.trim()) {
                    const rect = svgRef.current.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    addVertex(x, y);
                }
            };

            const loadJsonFile = (event) => {
                const file = event.target.files[0];
                if (file) {
                    setLoadedFileName(file.name);
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            updateGraphProperties(data);
                        } catch (error) {
                            alert('Error parsing JSON file: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const exportToJson = () => {
                const dataStr = JSON.stringify(graphData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const exportFileDefaultName = loadedFileName || 'graph.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            };

            const exportToMatrix = () => {
                const size = graphData.nodes.length;
                const matrix = Array(size).fill().map(() => Array(size).fill(0));
                
                graphData.edges.forEach(edge => {
                    const fromIndex = graphData.nodes.findIndex(n => n.id === edge.from);
                    const toIndex = graphData.nodes.findIndex(n => n.id === edge.to);
                    if (fromIndex !== -1 && toIndex !== -1) {
                        matrix[fromIndex][toIndex] = edge.weight;
                    }
                });
                
                const csvContent = "data:text/csv;charset=utf-8," + 
                    matrix.map(row => row.join(',')).join('\n');
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', encodeURI(csvContent));
                linkElement.setAttribute('download', 'adjacency_matrix.csv');
                linkElement.click();
            };

            const renderMatrix = () => {
                const size = graphData.nodes.length;
                if (size === 0) return "No vertices";
                
                const matrix = Array(size).fill().map(() => Array(size).fill(0));
                
                graphData.edges.forEach(edge => {
                    const fromIndex = graphData.nodes.findIndex(n => n.id === edge.from);
                    const toIndex = graphData.nodes.findIndex(n => n.id === edge.to);
                    if (fromIndex !== -1 && toIndex !== -1) {
                        matrix[fromIndex][toIndex] = edge.weight;
                    }
                });
                
                const header = "   " + graphData.nodes.map(n => n.label).join("  ");
                const rows = matrix.map((row, i) => 
                    graphData.nodes[i].label + "  " + row.map(val => val.toString().padStart(2)).join("  ")
                );
                
                return [header, ...rows].join('\n');
            };

            const renderEdges = () => {
                return graphData.edges.map((edge, index) => {
                    const fromNode = graphData.nodes.find(n => n.id === edge.from);
                    const toNode = graphData.nodes.find(n => n.id === edge.to);
                    
                    if (!fromNode || !toNode) return null;

                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / length;
                    const unitY = dy / length;
                    
                    const startX = fromNode.x + unitX * 25;
                    const startY = fromNode.y + unitY * 25;
                    const endX = toNode.x - unitX * 25;
                    const endY = toNode.y - unitY * 25;
                    
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;

                    return (
                        <g key={index}>
                            <line
                                x1={startX}
                                y1={startY}
                                x2={endX}
                                y2={endY}
                                className={edge.weight > 1 ? 'edge edge-weighted' : 'edge'}
                                onClick={() => removeEdge(edge.from, edge.to)}
                            />
                            {edge.label && (
                                <text
                                    x={midX}
                                    y={midY}
                                    className="edge-label"
                                >
                                    {edge.label}
                                </text>
                            )}
                        </g>
                    );
                });
            };

            const renderNodes = () => {
                return graphData.nodes.map((node) => (
                    <g
                        key={node.id}
                        className="node"
                        onClick={() => handleNodeClick(node.id)}
                    >
                        <circle
                            cx={node.x}
                            cy={node.y}
                            r="25"
                            className={`node-circle ${selectedNodes.includes(node.id) ? 'node-selected' : ''}`}
                        />
                        <text
                            x={node.x}
                            y={node.y}
                            className="node-text"
                        >
                            {node.label}
                        </text>
                    </g>
                ));
            };

            return (
                <div className="container">
                    <div className="header">
                        <h1>Interactive Graph Editor</h1>
                        <p>Create, edit, and visualize graphs with adjacency matrix export</p>
                    </div>
                    
                    <div className="main-content">
                        <div className="graph-section">
                            <svg 
                                ref={svgRef}
                                className="graph-svg" 
                                onClick={handleSvgClick}
                            >
                                <defs>
                                    <marker
                                        id="arrowhead"
                                        markerWidth="10"
                                        markerHeight="7"
                                        refX="9"
                                        refY="3.5"
                                        orient="auto"
                                    >
                                        <polygon
                                            points="0 0, 10 3.5, 0 7"
                                            fill="#666"
                                        />
                                    </marker>
                                </defs>
                                {renderEdges()}
                                {renderNodes()}
                            </svg>
                            
                            <div className="panel">
                                <div className="panel-title">Mode</div>
                                <div className="control-row">
                                    <button 
                                        className={mode === 'select' ? 'success' : ''}
                                        onClick={() => setMode('select')}
                                    >
                                        Select
                                    </button>
                                    <button 
                                        className={mode === 'addVertex' ? 'success' : ''}
                                        onClick={() => setMode('addVertex')}
                                    >
                                        Add Vertex
                                    </button>
                                </div>
                                <div style={{marginTop: '10px', fontSize: '12px', color: '#666'}}>
                                    {mode === 'select' && 'Click nodes to select them'}
                                    {mode === 'addVertex' && 'Click on canvas to add vertex'}
                                </div>
                            </div>
                        </div>
                        
                        <div className="sidebar">
                            <div className="panel">
                                <div className="panel-title">Add Vertex</div>
                                <div className="controls">
                                    <div className="control-row">
                                        <input
                                            type="text"
                                            placeholder="Vertex name"
                                            value={newVertexName}
                                            onChange={(e) => setNewVertexName(e.target.value)}
                                            onKeyPress={(e) => e.key === 'Enter' && addVertex()}
                                        />
                                        <button onClick={() => addVertex()}>Add</button>
                                    </div>
                                </div>
                            </div>

                            <div className="panel">
                                <div className="panel-title">Vertices</div>
                                <div className="vertex-list">
                                    {graphData.nodes.map(node => (
                                        <div 
                                            key={node.id}
                                            className={`vertex-tag ${selectedNodes.includes(node.id) ? 'selected' : ''}`}
                                            onClick={() => handleNodeClick(node.id)}
                                        >
                                            {node.label}
                                            <button 
                                                className="remove-btn"
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    removeVertex(node.id);
                                                }}
                                            >
                                                ×
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>

                            <div className="panel">
                                <div className="panel-title">Add/Edit Edge</div>
                                <div className="controls">
                                    <div style={{marginBottom: '10px', fontSize: '14px'}}>
                                        Selected: {selectedNodes.join(' → ')}
                                    </div>
                                    <div className="control-row">
                                        <input
                                            type="number"
                                            placeholder="Weight"
                                            value={edgeWeight}
                                            onChange={(e) => setEdgeWeight(e.target.value)}
                                            min="1"
                                        />
                                        <button 
                                            onClick={addEdge}
                                            disabled={selectedNodes.length !== 2}
                                        >
                                            Add Edge
                                        </button>
                                    </div>
                                    <div style={{fontSize: '12px', color: '#666'}}>
                                        Select exactly 2 vertices to add/edit edge
                                    </div>
                                </div>
                            </div>

                            <div className="panel">
                                <div className="panel-title">Graph Properties</div>
                                <div className="info-item">Vertices: {graphData.properties.vertices}</div>
                                <div className="info-item">Edges: {graphData.properties.edges}</div>
                                <div className="info-item">Density: {graphData.properties.density}</div>
                            </div>

                            <div className="panel">
                                <div className="panel-title">Adjacency Matrix</div>
                                <div className="matrix-display">
                                    <pre>{renderMatrix()}</pre>
                                </div>
                            </div>

                            <div className="panel">
                                <div className="panel-title">File Operations</div>
                                <div className="controls">
                                    <input
                                        type="file"
                                        accept=".json"
                                        onChange={loadJsonFile}
                                        ref={fileInputRef}
                                        style={{display: 'none'}}
                                    />
                                    <button onClick={() => fileInputRef.current?.click()}>
                                        Load Graph JSON
                                    </button>
                                    
                                    <div className="download-section">
                                        <button onClick={exportToJson} className="success">
                                            Export to JSON
                                        </button>
                                        <button onClick={exportToMatrix} className="success">
                                            Export Matrix CSV
                                        </button>
                                    </div>
                                    
                                    {loadedFileName && (
                                        <div style={{fontSize: '12px', color: '#666', marginTop: '10px'}}>
                                            Loaded: {loadedFileName}
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<GraphEditor />, document.getElementById('root'));
    </script>
</body>
</html>